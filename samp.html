<!DOCTYPE html>
<html>
<head>
  <title>Digital - Brass Oil Lamp</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #080604; font-family: 'Georgia', serif; }
    #canvas-container { width: 100vw; height: 100vh; position: relative; }
    #ui {
      position: absolute; bottom: 28px; left: 50%; transform: translateX(-50%);
      text-align: center; color: #d4a030; pointer-events: none;
      text-shadow: 0 0 24px rgba(255,160,30,0.5);
    }
    #ui h2 { font-size: 1.9rem; letter-spacing: 0.35em; text-transform: uppercase; margin-bottom: -20px; color: rgb(255, 255, 255); text-shadow: 0 0 22px rgba(2, 0, 0, 1.75); }
    #ui p  { font-size: 0.7rem; letter-spacing: 0.18em; opacity: 0.5; }
    #hint {
      position: absolute; top: 22px; left: 50%; transform: translateX(-50%);
      color: rgba(210,160,40,0.75); font-size: 0.76rem; letter-spacing: 0.18em;
      text-transform: uppercase; white-space: nowrap; transition: color 0.5s;
    }
    #flame-dots {
      position: absolute; top: 54px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 10px;
    }
    .dot {
      width: 9px; height: 9px; border-radius: 50%;
      border: 1.5px solid rgba(200,146,42,0.45); background: transparent;
      transition: background 0.5s, box-shadow 0.5s;
    }
    .dot.lit { background: #ffaa22; box-shadow: 0 0 9px 3px rgba(255,160,30,0.75); border-color: #ffaa22; }
  </style>
</head>
<body>
<div id="canvas-container">
  <div id="hint">Press <strong>Enter</strong> to light a flame &nbsp;·&nbsp; Drag to rotate</div>
  <div id="flame-dots">
    <div class="dot" id="dot-0"></div><div class="dot" id="dot-1"></div>
    <div class="dot" id="dot-2"></div><div class="dot" id="dot-3"></div>
    <div class="dot" id="dot-4"></div>
  </div>
  <div id="ui">
    <h2>WELCOME</h2>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ─── RENDERER ────────────────────────────────────────────────
const container = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.35;
renderer.outputEncoding = THREE.sRGBEncoding;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x080604);
scene.fog = new THREE.FogExp2(0x080604, 0.026);

const camera = new THREE.PerspectiveCamera(46, innerWidth/innerHeight, 0.01, 500);
camera.position.set(0, 3, 17);
camera.lookAt(0, 2.5, 0);

// ─── MATERIALS ───────────────────────────────────────────────
const brass = new THREE.MeshStandardMaterial({
  color: 0xf2c438, metalness: 0.97, roughness: 0.13
});
const brassDark = new THREE.MeshStandardMaterial({
  color: 0xcfa020, metalness: 0.97, roughness: 0.20
});

// ─── LATHE BUILDER ───────────────────────────────────────────
function mkLathe(pts, segs, mat) {
  segs = segs || 96; mat = mat || brass;
  const v2  = pts.map(p => new THREE.Vector2(p[0], p[1]));
  const geo = new THREE.LatheGeometry(v2, segs);
  geo.computeVertexNormals();
  const m = new THREE.Mesh(geo, mat);
  m.castShadow = true; m.receiveShadow = true;
  return m;
}

// ─── LAMP GROUP ──────────────────────────────────────────────
const lamp = new THREE.Group();
scene.add(lamp);

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 1. BASE PLATE — very wide flat dish, thin rim curl
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  [0.00, 0.00],
  [2.60, 0.00],  // wide flat bottom
  [2.78, 0.04],  // sweep outward
  [2.88, 0.14],  // rim up-curve
  [2.90, 0.26],  // rim top
  [2.82, 0.38],  // rim inner drop
  [2.60, 0.46],
  [2.30, 0.52],
  [1.90, 0.56],
  [1.55, 0.58],
  [1.28, 0.60],
]));

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 2. BASE COLLAR — stepped cylindrical riser
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  [1.28, 0.60],
  [1.38, 0.68],
  [1.46, 0.80],  // flare out
  [1.48, 0.94],
  [1.44, 1.06],
  [1.34, 1.16],
  [1.18, 1.24],
  [1.04, 1.28],
]));

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 3. LOWER TAPER SHAFT
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  [1.04, 1.28],
  [0.94, 1.40],
  [0.82, 1.60],
  [0.72, 1.86],
  [0.66, 2.14],
  [0.64, 2.32],
]));

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 4. LOWER BULB — prominent round node
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  [0.64, 2.32],
  [0.70, 2.44],
  [0.82, 2.58],
  [0.94, 2.76],
  [1.02, 2.96],  // widest point
  [1.04, 3.10],
  [1.00, 3.28],
  [0.90, 3.46],
  [0.76, 3.60],
  [0.64, 3.68],
  [0.58, 3.74],
]));

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5. WAIST — narrow transition before ringed section
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  [0.58, 3.74],
  [0.54, 3.84],
  [0.52, 3.96],
  [0.52, 4.06],
]));

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 6. RINGED SHAFT — 6 crisp defined rings
//    Each ring = waist(0.50) → shoulder(0.58) → peak(0.64) → shoulder(0.58) → waist(0.50)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(function() {
  const pts = [[0.52, 4.06]];
  const baseY = 4.06;
  const ringH = 0.28; // height of each ring unit
  const n = 6;
  for (let r = 0; r < n; r++) {
    const y0 = baseY + r * ringH;
    pts.push([0.50, y0 + 0.00]); // waist entry
    pts.push([0.57, y0 + 0.07]); // shoulder
    pts.push([0.64, y0 + 0.14]); // peak
    pts.push([0.57, y0 + 0.21]); // shoulder
    pts.push([0.50, y0 + 0.28]); // waist exit
  }
  pts.push([0.52, baseY + n * ringH]);
  lamp.add(mkLathe(pts, 96));
})();

const RING_TOP = 4.06 + 6 * 0.28; // = 5.74

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 7. UPPER TAPER into second bulb
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  [0.52, RING_TOP],
  [0.54, RING_TOP + 0.08],
  [0.58, RING_TOP + 0.18],
  [0.62, RING_TOP + 0.28],
]));

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 8. UPPER BULB — smaller, more elegant
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
const UB = RING_TOP + 0.28;
lamp.add(mkLathe([
  [0.62, UB],
  [0.70, UB+0.12],
  [0.80, UB+0.26],
  [0.88, UB+0.42],  // widest
  [0.88, UB+0.58],
  [0.82, UB+0.74],
  [0.72, UB+0.88],
  [0.60, UB+0.98],
  [0.52, UB+1.04],
]));

const NB = UB + 1.04; // = top of upper bulb

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 9. NECK RING — small decorative collar
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  [0.52, NB],
  [0.56, NB+0.06],
  [0.64, NB+0.13],  // ring peak
  [0.68, NB+0.20],
  [0.64, NB+0.27],
  [0.56, NB+0.33],
  [0.50, NB+0.38],
]));

const NK = NB + 0.38;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 10. BOWL SUPPORT CONE — widens up to bowl
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  [0.50, NK],
  [0.56, NK+0.08],
  [0.68, NK+0.18],
  [0.86, NK+0.28],
  [1.08, NK+0.38],
  [1.32, NK+0.46],
]));

const BW = NK + 0.46; // bowl base

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 11. BOWL — wide concave dish with defined rim
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  [1.32, BW],
  [1.65, BW+0.06],
  [2.00, BW+0.14],
  [2.30, BW+0.24],
  [2.52, BW+0.36],
  [2.65, BW+0.50],  // outer slope
  [2.72, BW+0.64],  // near rim
  [2.76, BW+0.78],  // rim outer peak
  [2.72, BW+0.92],  // rim falls inward
  [2.58, BW+1.02],
  [2.36, BW+1.10],
  [2.06, BW+1.16],
  [1.70, BW+1.18],
  [1.30, BW+1.16],
  [0.96, BW+1.10],
  [0.70, BW+1.02],
  [0.54, BW+0.94],
], 100, brassDark));

const BOWL_TOP = BW + 1.18;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 12. PETAL LOBES — 5 pointed tips at rim
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
const NUM_WICKS = 5;
for (let i = 0; i < NUM_WICKS; i++) {
  const ang = (i / NUM_WICKS) * Math.PI * 2;
  const R = 2.72;

  // Petal lobe — elongated ellipsoid
  const petalGeo = new THREE.SphereGeometry(0.24, 22, 14);
  const petal = new THREE.Mesh(petalGeo, brass);
  petal.scale.set(0.62, 0.42, 1.55);
  petal.position.set(Math.cos(ang)*R, BW+0.88, Math.sin(ang)*R);
  petal.rotation.y = -ang;
  petal.castShadow = true;
  lamp.add(petal);

  // Small wick nub
  const nubGeo = new THREE.CylinderGeometry(0.055, 0.09, 0.20, 10);
  const nub    = new THREE.Mesh(nubGeo, brassDark);
  nub.position.set(Math.cos(ang)*(R+0.06), BW+1.02, Math.sin(ang)*(R+0.06));
  nub.rotation.y = -ang;
  lamp.add(nub);
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 13. FINIAL BASE DISC — where finial rises from center
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  [0.54, BW+0.94],
  [0.50, BW+1.02],
  [0.52, BW+1.10],
  [0.54, BW+1.20],
  [0.50, BW+1.30],
  [0.44, BW+1.38],
  [0.40, BW+1.44],
]));

const FIN = BW + 1.44; // finial start

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 14. FINIAL — tall elegant 3-section ornament
//     Section A: lower ball
//     Section B: neck + middle ball (widest)
//     Section C: upper taper to point
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lamp.add(mkLathe([
  // Section A — lower ball
  [0.40, FIN],
  [0.46, FIN+0.10],
  [0.52, FIN+0.22],  // ball peak
  [0.54, FIN+0.34],
  [0.50, FIN+0.48],
  [0.42, FIN+0.58],
  [0.32, FIN+0.66],  // neck
  // Section B — mid ball (largest)
  [0.36, FIN+0.76],
  [0.48, FIN+0.88],
  [0.58, FIN+1.02],  // mid ball peak
  [0.62, FIN+1.18],
  [0.58, FIN+1.34],
  [0.46, FIN+1.48],
  [0.34, FIN+1.58],  // neck
  // Section C — upper taper to sharp point
  [0.28, FIN+1.68],
  [0.32, FIN+1.80],
  [0.34, FIN+1.94],  // small tip ball
  [0.30, FIN+2.08],
  [0.20, FIN+2.24],
  [0.10, FIN+2.42],
  [0.02, FIN+2.60],
  [0.00, FIN+2.68],  // tip
], 72));

lamp.position.y = -5.0;

// ─── GROUND ──────────────────────────────────────────────────
const ground = new THREE.Mesh(
  new THREE.CircleGeometry(22, 80),
  new THREE.MeshStandardMaterial({ color: 0x0e0a05, metalness: 0.15, roughness: 0.92 })
);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -5.0;
ground.receiveShadow = true;
scene.add(ground);

// ─── LIGHTING ────────────────────────────────────────────────
scene.add(new THREE.AmbientLight(0x281806, 1.6));

// Key — warm from upper-left front
const key = new THREE.DirectionalLight(0xffd080, 3.2);
key.position.set(-5, 16, 9);
key.castShadow = true;
key.shadow.mapSize.set(2048, 2048);
key.shadow.camera.near = 0.5; key.shadow.camera.far = 80;
key.shadow.camera.left = -16; key.shadow.camera.right = 16;
key.shadow.camera.top = 16; key.shadow.camera.bottom = -16;
scene.add(key);

// Fill — from right
const fill = new THREE.DirectionalLight(0x7a4010, 1.0);
fill.position.set(10, 6, -3);
scene.add(fill);

// Rim — from behind
const rim = new THREE.DirectionalLight(0xff9820, 0.85);
rim.position.set(0, 9, -18);
scene.add(rim);

// Top — straight above
const topLight = new THREE.DirectionalLight(0xffcc60, 1.3);
topLight.position.set(2, 20, 2);
scene.add(topLight);

// ─── FLAMES ──────────────────────────────────────────────────
const FLAME_Y = lamp.position.y + BW + 1.22;
const FLAME_R = 2.62;
const flames = [], flameLights = [];

for (let i = 0; i < NUM_WICKS; i++) {
  const ang = (i / NUM_WICKS) * Math.PI * 2;
  const fx  = Math.cos(ang) * FLAME_R;
  const fz  = Math.sin(ang) * FLAME_R;

  const outerGeo = new THREE.ConeGeometry(0.19, 1.05, 22, 1, true);
  const outerMat = new THREE.MeshStandardMaterial({
    color: 0xff7200, emissive: 0xff3e00, emissiveIntensity: 3.8,
    transparent: true, opacity: 0.88, side: THREE.DoubleSide, depthWrite: false
  });
  const outer = new THREE.Mesh(outerGeo, outerMat);
  outer.position.set(fx, FLAME_Y, fz);
  outer.visible = false;
  scene.add(outer);

  const innerGeo = new THREE.ConeGeometry(0.085, 0.62, 16, 1, true);
  const innerMat = new THREE.MeshStandardMaterial({
    color: 0xffee77, emissive: 0xffffaa, emissiveIntensity: 6.5,
    transparent: true, opacity: 0.95, side: THREE.DoubleSide, depthWrite: false
  });
  const inner = new THREE.Mesh(innerGeo, innerMat);
  inner.position.set(fx, FLAME_Y + 0.05, fz);
  inner.visible = false;
  scene.add(inner);

  flames.push({ outer, inner, lit: false });

  const fl = new THREE.PointLight(0xff9933, 0, 10, 2);
  fl.position.set(fx, FLAME_Y + 0.4, fz);
  scene.add(fl);
  flameLights.push(fl);
}

const centerGlow = new THREE.PointLight(0xffb040, 0, 16, 2);
centerGlow.position.set(0, FLAME_Y + 1.3, 0);
scene.add(centerGlow);

// ─── SEQUENCING ──────────────────────────────────────────────
let litCount = 0;
const hintEl = document.getElementById('hint');

function lightNext() {
  if (litCount >= NUM_WICKS) return;
  const i = litCount;
  flames[i].outer.visible = true;
  flames[i].inner.visible = true;
  flames[i].lit = true;
  flameLights[i].intensity = 2.4;
  centerGlow.intensity = 0.7 * (litCount + 1);
  document.getElementById('dot-' + i).classList.add('lit');
  litCount++;
  hintEl.innerHTML = litCount === NUM_WICKS
    ? 'Drag to rotate · Scroll to zoom'
    : `Press <strong>Enter</strong> to light flame ${litCount + 1} of 5`;
}
window.addEventListener('keydown', e => { if (e.key === 'Enter') lightNext(); });

// ─── SPARKS ──────────────────────────────────────────────────
const SPARK_N = 140;
const spkPos  = new Float32Array(SPARK_N * 3);
const spkData = [];
for (let i = 0; i < SPARK_N; i++) {
  const wi = i % NUM_WICKS, ang = (wi / NUM_WICKS) * Math.PI * 2;
  spkData.push({
    ox: Math.cos(ang)*FLAME_R, oz: Math.sin(ang)*FLAME_R, oy: FLAME_Y,
    t: Math.random()*Math.PI*2, speed: 0.35+Math.random()*0.65,
    spread: 0.07+Math.random()*0.13, life: Math.random(), wi
  });
  spkPos[i*3] = spkPos[i*3+1] = spkPos[i*3+2] = 9999;
}
const spkGeo = new THREE.BufferGeometry();
spkGeo.setAttribute('position', new THREE.BufferAttribute(spkPos, 3));
const spkMat = new THREE.PointsMaterial({
  color: 0xffcc44, size: 0.055, transparent: true, opacity: 0.78,
  depthWrite: false, blending: THREE.AdditiveBlending
});
scene.add(new THREE.Points(spkGeo, spkMat));

// ─── ORBIT ───────────────────────────────────────────────────
let drag=false, prevM={x:0,y:0}, theta=0.3, phi=0.20, radius=17;
const TY = 2.5;

renderer.domElement.addEventListener('mousedown', e=>{ drag=true; prevM={x:e.clientX,y:e.clientY}; });
renderer.domElement.addEventListener('mouseup',   ()=>drag=false);
renderer.domElement.addEventListener('mousemove', e=>{
  if(!drag) return;
  theta -= (e.clientX-prevM.x)*0.008;
  phi = Math.max(0.05, Math.min(1.15, phi+(e.clientY-prevM.y)*0.006));
  prevM = {x:e.clientX,y:e.clientY};
});
renderer.domElement.addEventListener('wheel', e=>{
  radius = Math.max(7, Math.min(30, radius+e.deltaY*0.022));
});
let lT=null;
renderer.domElement.addEventListener('touchstart', e=>{ lT=e.touches[0]; drag=true; });
renderer.domElement.addEventListener('touchend',   ()=>{ drag=false; lT=null; });
renderer.domElement.addEventListener('touchmove',  e=>{
  if(!lT) return;
  theta-=(e.touches[0].clientX-lT.clientX)*0.010;
  phi=Math.max(0.05,Math.min(1.15,phi+(e.touches[0].clientY-lT.clientY)*0.008));
  lT=e.touches[0];
});

// ─── ANIMATE ─────────────────────────────────────────────────
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  if (!drag) theta += 0.0022;
  camera.position.set(
    Math.sin(theta)*Math.cos(phi)*radius,
    Math.sin(phi)*radius + TY,
    Math.cos(theta)*Math.cos(phi)*radius
  );
  camera.lookAt(0, TY, 0);

  flames.forEach((f, i) => {
    if (!f.lit) return;
    const flicker = Math.sin(t*13.5+i*1.6)*0.09 + Math.sin(t*8.2+i*2.4)*0.055;
    const sway    = Math.sin(t*5.1+i*1.2)*0.032;
    f.outer.scale.set(1+sway, 1+flicker, 1+sway);
    f.inner.scale.set(1-sway*0.4, 1+flicker*1.5, 1-sway*0.4);
    f.outer.material.emissiveIntensity = 3.4 + Math.random()*1.6;
    f.inner.material.emissiveIntensity = 5.5 + Math.random()*2.2;
    flameLights[i].intensity = 2.3 + Math.sin(t*11.5+i*2.0)*0.5 + Math.random()*0.45;
    flameLights[i].color.setHSL(0.075 + Math.random()*0.03, 1, 0.54);
  });
  if (litCount > 0) centerGlow.intensity = 0.65*litCount + Math.sin(t*7)*0.28;

  const sp = spkGeo.attributes.position.array;
  spkData.forEach((s,i) => {
    if (!flames[s.wi].lit) { sp[i*3]=sp[i*3+1]=sp[i*3+2]=9999; return; }
    s.life += s.speed*0.011;
    if (s.life>1) { s.life=0; s.t=Math.random()*Math.PI*2; }
    const h = s.life;
    sp[i*3]   = s.ox + Math.sin(s.t+t*3.2)*s.spread*h;
    sp[i*3+1] = s.oy + h*1.7;
    sp[i*3+2] = s.oz + Math.cos(s.t+t*3.2)*s.spread*h;
  });
  spkGeo.attributes.position.needsUpdate = true;
  spkMat.opacity = 0.64 + Math.sin(t*2.8)*0.12;

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>